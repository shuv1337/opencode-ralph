/**
 * Plugin template for the Ralph write-guardrail plugin.
 * Extracted from init.ts for better code organization.
 */

/**
 * Marker for generated plugin files.
 * This marker indicates the file was created by `ralph init` and is safe to remove with `ralph --reset`.
 */
export const GENERATED_PLUGIN_MARKER = `// Generated by ralph init
// generator: ralph-init
// safe_to_delete: true
`;

/**
 * Check if a plugin file was generated by ralph init.
 */
export function isGeneratedPlugin(content: string): boolean {
  return content.startsWith("// Generated by ralph init");
}

/**
 * Detect if an edit's newString indicates task completion.
 * Looks for the specific combination of "status": "done" AND "passes": true.
 * Supports both JSON-formatted strings and partial property updates.
 * 
 * Platform agnostic - works on Windows, Linux, and macOS.
 * 
 * @param newString - The replacement content from the edit tool
 * @returns true if the edit marks a task as completed
 */
export function detectsTaskCompletion(newString: string): boolean {
  if (!newString || newString.trim().length < 5) {
    return false;
  }

  // Normalize line endings for cross-platform support
  const normalized = newString.replace(/\r\n/g, "\n").replace(/\r/g, "\n");

  // Check for status: "done" or "status": "done"
  const hasDoneStatus = 
    /["']?status["']?\s*:\s*["']done["']/i.test(normalized) ||
    /"status"\s*:\s*"done"/i.test(normalized);

  // Check for passes: true or "passes": true
  const hasPassesTrue = 
    /["']?passes["']?\s*:\s*true/i.test(normalized) ||
    /"passes"\s*:\s*true/i.test(normalized);

  return hasDoneStatus && hasPassesTrue;
}

/**
 * Template for the write-guardrail plugin.
 * This plugin protects specified files from being overwritten or modified by AI agents.
 */
export const PLUGIN_TEMPLATE = `${GENERATED_PLUGIN_MARKER}
import type { Plugin } from "@opencode-ai/plugin"

/**
 * Ralph Write Guardrail Plugin
 * 
 * Protects user-configurable files from being overwritten or deleted by:
 * - Write tool: Blocks full file overwrites
 * - Bash tool: Blocks commands that overwrite/delete protected files
 * - Edit tool on prd.json: Limited to ONE TASK per session (multiple edits to same task OK)
 * 
 * SESSION COMPLETION LOCK:
 * Once Ralph marks a task as "done" with passes=true, the prd.json file is locked
 * for the remainder of that session. This ensures:
 * - Ralph completes exactly ONE task per iteration
 * - No further modifications can be made until a new session starts
 * - The lock resets automatically when a new iteration/session begins
 * 
 * The one-task-per-session rule for prd.json ensures Ralph makes focused,
 * incremental progress. Multiple edits to the SAME task are allowed
 * (e.g., pending → active → done lifecycle transitions) until completion.
 * 
 * Protected files by default:
 * - prd.json - The PRD plan file (1 task per session, locked after completion)
 * - progress.txt - Progress tracking
 * - .ralph-prompt.md - Prompt template
 * - AGENTS.md - Agent configuration
 * 
 * To customize, modify the PROTECTED_FILES array below.
 */

// Files that should be protected from AI modification
const PROTECTED_FILES = [
  "prd.json",
  "progress.txt",
  ".ralph-prompt.md",
  "AGENTS.md",
]

// Session-level tracking for prd.json task edits
// Tracks which task INDEX is being edited this session (resets when OpenCode restarts)
// This allows multiple edits to the SAME task (e.g., pending → active → done)
// but blocks editing DIFFERENT tasks in the same session
let activeTaskIndex: number | null = null

// Session completion lock - blocks ALL further edits to prd.json once a task is completed
// This ensures Ralph can only complete ONE task per session/iteration
let isPlanLockedThisSession: boolean = false

// Transient flag between before and after hooks
// Set to true in before hook when completion is detected, activated in after hook on success
let pendingLockActivation: boolean = false

const PRD_FILE_NAME = "prd.json"

/**
 * Find which task index in prd.json contains the given content.
 * Reads the file, parses JSON, and searches each item for the content.
 * Returns the 0-based index of the matching task, or null if not found/ambiguous.
 */
async function findTaskIndexByContent(filePath: string, searchContent: string): Promise<number | null> {
  if (!searchContent || searchContent.trim().length < 5) {
    // Content too short to reliably match
    return null
  }
  
  try {
    const file = Bun.file(filePath)
    if (!(await file.exists())) return null
    
    const content = await file.text()
    const parsed = JSON.parse(content)
    const items: unknown[] = Array.isArray(parsed) ? parsed : (parsed?.items || null)
    
    if (!items || !Array.isArray(items)) return null
    
    const matches: number[] = []
    
    for (let i = 0; i < items.length; i++) {
      const itemJson = JSON.stringify(items[i])
      // Check if the search content is found within this item's JSON
      // or if this item's content is found within the search content
      if (itemJson.includes(searchContent) || searchContent.includes(itemJson)) {
        matches.push(i)
      }
    }
    
    // Only return if exactly ONE item matches (unambiguous)
    if (matches.length === 1) {
      return matches[0]
    }
    
    // If multiple or zero matches, try a more granular search
    // Look for unique field combinations in the search content
    if (matches.length === 0) {
      // Try matching on significant substrings (description field values)
      const descMatch = searchContent.match(/["']description["']\\s*:\\s*["']([^"']{15,})["']/)
      if (descMatch) {
        const desc = descMatch[1]
        for (let i = 0; i < items.length; i++) {
          const item = items[i] as Record<string, unknown>
          if (typeof item?.description === "string" && item.description.includes(desc)) {
            return i
          }
        }
      }
    }
    
    return matches.length === 1 ? matches[0] : null
  } catch {
    return null
  }
}

// Patterns for destructive bash commands targeting files
const DESTRUCTIVE_COMMAND_PATTERNS = [
  // rm commands
  /^rm\\s+.*\\b(FILENAME)\\b/,
  /^rm\\s+-[rf]+\\s+.*\\b(FILENAME)\\b/,
  // mv commands (moving/renaming protected files)
  /^mv\\s+.*\\b(FILENAME)\\b/,
  // cp overwriting protected files (cp source dest where dest is protected)
  /^cp\\s+.*\\s+(FILENAME)\\s*$/,
  // Redirect operators that would overwrite
  /[>|]\\s*(FILENAME)\\b/,
  // truncate command
  /^truncate\\s+.*\\b(FILENAME)\\b/,
  // shred command
  /^shred\\\\s+.*\\\\b(FILENAME)\\\\b/,
  // git rm - explicitly removes file from repository
  /git\\\\s+rm\\\\s+.*\\\\b(FILENAME)\\\\b/,
  // git mv - moves/renames file in repository
  /git\\\\s+mv\\\\s+.*\\\\b(FILENAME)\\\\b/,
]

/**
 * Strips quoted content from a command to avoid false positives.
 * This removes content inside single quotes, double quotes, and backticks
 * so that commit messages and other quoted strings don't trigger keyword checks.
 * 
 * For example: git commit -m "Updated AGENTS.md with Crossterm docs"
 * The quoted message won't trigger "rm " detection from "Crossterm " substring.
 * 
 * Platform agnostic - works on Windows, Linux, and macOS.
 */
function stripQuotedContent(command: string): string {
  let result = command
  
  // Remove double-quoted strings (handles escaped quotes inside)
  result = result.replace(/"(?:[^"\\\\]|\\\\.)*"/g, '""')
  
  // Remove single-quoted strings (no escape processing in single quotes)
  result = result.replace(/'[^']*'/g, "''")
  
  return result
}

/**
 * Checks if a file path matches any protected file.
 * Handles both absolute and relative paths.
 */
function isProtectedFile(filePath: string): string | null {
  const normalizedPath = filePath.replace(/\\\\/g, "/")
  for (const protectedFile of PROTECTED_FILES) {
    if (
      normalizedPath === protectedFile ||
      normalizedPath.endsWith("/" + protectedFile) ||
      normalizedPath.endsWith("\\\\" + protectedFile)
    ) {
      return protectedFile
    }
  }
  return null
}

/**
 * Checks if a bash command would modify any protected file.
 * 
 * Uses a two-phase approach:
 * 1. First checks regex patterns against the FULL command (for redirect operators, etc.)
 * 2. Then checks keyword presence against command with quoted content STRIPPED
 *    (to avoid false positives from commit messages mentioning protected files)
 * 
 * This prevents false positives where commit messages contain words like "Crossterm"
 * which would incorrectly match the "rm " dangerous keyword check.
 * 
 * Platform agnostic - works on Windows, Linux, and macOS.
 */
function wouldModifyProtectedFile(command: string): string | null {
  // Strip quoted content for keyword checks to avoid false positives
  // from commit messages that mention protected files or contain words like "Crossterm"
  const unquotedCommand = stripQuotedContent(command)
  
  for (const protectedFile of PROTECTED_FILES) {
    // Create file-specific patterns
    const escapedFileName = protectedFile.replace(/[.*+?^\${}()|[\\]\\\\]/g, "\\\\$&")
    
    // Phase 1: Check regex patterns against the FULL command
    // This catches things like: echo "test" > prd.json (redirect outside quotes)
    for (const patternTemplate of DESTRUCTIVE_COMMAND_PATTERNS) {
      const pattern = new RegExp(
        patternTemplate.source.replace(/FILENAME/g, escapedFileName),
        patternTemplate.flags
      )
      if (pattern.test(command)) {
        return protectedFile
      }
    }
    
    // Phase 2: Check for protected file in UNQUOTED part of command with dangerous patterns
    // This avoids false positives from quoted content like commit messages
    if (unquotedCommand.includes(protectedFile)) {
      // Use word-boundary aware patterns for dangerous commands
      // These patterns ensure we match actual commands, not substrings in words like "Crossterm"
      const dangerousPatterns = [
        /(?:^|[;&|])\\s*rm\\s/,        // rm command at start or after separator
        /(?:^|[;&|])\\s*mv\\s/,        // mv command
        /(?:^|[;&|])\\s*truncate\\s/,  // truncate command
        /(?:^|[;&|])\\s*shred\\s/,     // shred command
        />\\s*$/,                       // redirect at end of unquoted part
        />>\\s*$/,                      // append redirect at end
      ]
      
      for (const pattern of dangerousPatterns) {
        if (pattern.test(unquotedCommand)) {
          return protectedFile
        }
      }
    }
  }
  return null
}

/**
 * Detect if an edit's newString indicates task completion.
 * Looks for the specific combination of "status": "done" AND "passes": true.
 * Supports both JSON-formatted strings and partial property updates.
 * 
 * Platform agnostic - works on Windows, Linux, and macOS.
 */
function detectsTaskCompletion(newString: string): boolean {
  if (!newString || newString.trim().length < 5) {
    return false
  }

  // Normalize line endings for cross-platform support
  const normalized = newString.replace(/\\r\\n/g, "\\n").replace(/\\r/g, "\\n")

  // Check for status: "done" or "status": "done"
  const hasDoneStatus = 
    /["']?status["']?\\s*:\\s*["']done["']/i.test(normalized) ||
    /"status"\\s*:\\s*"done"/i.test(normalized)

  // Check for passes: true or "passes": true
  const hasPassesTrue = 
    /["']?passes["']?\\s*:\\s*true/i.test(normalized) ||
    /"passes"\\s*:\\s*true/i.test(normalized)

  return hasDoneStatus && hasPassesTrue
}

export const RalphWriteGuardrail: Plugin = async () => {
  return {
    // Reset all session-level tracking when a new session starts
    // This ensures the guardrail state is clean for each iteration
    event: async ({ event }) => {
      if (event.type === "session.created") {
        activeTaskIndex = null
        isPlanLockedThisSession = false
        pendingLockActivation = false
      }
    },
    "tool.execute.before": async (input, output) => {
      // Guard against write tool (full file overwrites)
      // Note: Edit tool is NOT blocked - surgical edits are the preferred approach
      if (input.tool === "write") {
        const filePath = output.args?.filePath as string | undefined
        if (filePath) {
          const protectedFile = isProtectedFile(filePath)
          if (protectedFile) {
            throw new Error(
              \`[Ralph Guardrail] Cannot overwrite protected file: \${protectedFile}. \\n\` +
              \`This file is managed by Ralph and should not be modified directly by AI. \\n\` +
              \`Use the Edit tool for surgical changes instead.\`
            )
          }
        }
      }

      // Guard against bash commands that could modify protected files
      if (input.tool === "bash") {
        const command = output.args?.command as string | undefined
        if (command) {
          const protectedFile = wouldModifyProtectedFile(command)
          if (protectedFile) {
            throw new Error(
              \`[Ralph Guardrail] Bash command would modify protected file: \${protectedFile}. \\n\` +
              \`Command: \${command}\\n\` +
              \`This file is managed by Ralph and should not be modified by shell commands.\`
            )
          }
        }
      }

      // Guard against editing DIFFERENT tasks in prd.json within a single session
      // Ralph should focus on ONE task per iteration, but can make multiple edits to that task
      // (e.g., pending → active → done lifecycle is allowed) UNTIL task is marked complete
      if (input.tool === "edit") {
        const filePath = output.args?.filePath as string | undefined
        if (filePath) {
          const normalizedPath = filePath.replace(/\\\\/g, "/")
          const isPrdFile = normalizedPath === PRD_FILE_NAME || 
                           normalizedPath.endsWith("/" + PRD_FILE_NAME) ||
                           normalizedPath.endsWith("\\\\" + PRD_FILE_NAME)
          
          if (isPrdFile) {
            // SESSION COMPLETION LOCK: Block ALL edits if a task was already completed
            if (isPlanLockedThisSession) {
              throw new Error(
                \`[Ralph Guardrail] Task completed this session. Blocking further edits to prd.json. \\n\` +
                \`To ensure incremental progress, only one task can be completed per iteration. \\n\` +
                \`Start a new iteration to continue with the next task.\`
              )
            }

            // Find which task is being edited by matching oldString against file content
            const oldString = output.args?.oldString as string | undefined
            const newString = output.args?.newString as string | undefined
            
            if (oldString && oldString.length >= 5) {
              const taskIndex = await findTaskIndexByContent(filePath, oldString)
              
              if (taskIndex !== null) {
                if (activeTaskIndex === null) {
                  // First edit this session - record the task index
                  activeTaskIndex = taskIndex
                } else if (activeTaskIndex !== taskIndex) {
                  // Trying to edit a DIFFERENT task - block it
                  throw new Error(
                    \`[Ralph Guardrail] Cannot edit multiple tasks in prd.json in a single session. \\\\n\` +
                    \`You are already working on task at index \${activeTaskIndex}. \\\\n\` +
                    \`Attempted to edit task at index \${taskIndex}. \\\\n\` +
                    \`Complete the current task first, then Ralph will start a new iteration for the next task.\`
                  )
                }
                // Same task index - allow the edit (supports status lifecycle changes)
              }
              // If we couldn't determine task index, allow the edit (fail-open for edge cases)
            }

            // Check if this edit marks the task as complete
            // If so, set the pending lock flag (will be activated in after hook on success)
            if (newString && detectsTaskCompletion(newString)) {
              pendingLockActivation = true
            }
          }
        }
      }
    },
    // Activate the session lock AFTER a successful edit that marks task as complete
    // This ensures we don't lock if the edit fails (allows retry)
    "tool.execute.after": async (input, output) => {
      if (input.tool === "edit" && pendingLockActivation) {
        // The edit succeeded, activate the lock
        isPlanLockedThisSession = true
        pendingLockActivation = false
      }
    },
  }
}
`;
